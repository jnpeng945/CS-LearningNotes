> Linux 高性能服务器编程_游双



[TOC]



# 第一篇 TCP/IP 协议详解

理解底层 TCP / IP 通信过程。

## 第 1 章 TCP/IP 协议族

后续详解 IP 协议以及 TCP 协议，本章讨论 ICMP、ARP、DNS 协议。

### 1.1 TCP/IP 协议族体系结构以及主要协议

TCP/IP 协议族：一个四层协议系统，**下层协议为上层协议提供服务**。



<div align="center"> <img src="Figs/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B_1.png" width="700"/> </div><br>

#### 1.1.1 数据链路层

实现网卡接口的网络驱动程序，以处理数据在物理媒介上的传输。

**ARP 协议**（Address Resolve Protocol，地址解析协议）：IP 地址转换为 MAC 地址；

- 网络层使用 IP 地址寻址机器，数据链路层使用 MAC 地址寻址机器，因此网络层要将目标机器的 IP 地址转化为 MAC 地址，才能使用数据链路层提供的服务。

**RARP 协议** （Reverse Address Resolve Protocol，逆地址解析协议）。

- 无盘工作站缺少存储设备，无法记住自己的 IP 地址，但它们利用网卡上的 MAC 地址向服务器查询自身的 IP 地址。（运行 RARP 服务的服务器上存有该网络上所有机器的 MAC 地址到 IP 地址的映射。）

#### 1.1.2 网络层

实现数据包的选路和转发。网络层对上层协议隐藏了网络拓扑连接的细节，使得在传输层和网络应用程序看来，通信双方是直接相连的。

**ICMP 协议**（Internet Control Message Protocol，因特网控制报文协议）：用于检测网络连接，其使用的报文格式如下：

<div align="center"> <img src="Figs/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B_2.png" width="700"/> </div><br>

- 8 位类型字段：<u>区分报文类型</u>。其将 ICMP 报文分为两类，一类是用于回应网络错误的**差错报文**，如目标不可达（类型值为 3）和重定向（类型值为 5）；另一类是用于查询网络信息的**查询报文**，如 ping 程序就是用 ICMP 报文查看目标是否可达（类型值为 8）。
- 8 位代码字段：进一步细分不同的条件，如重定向报文使用代码值 0 表示对网络重定向，代码值 1 表示对主机重定向。
- 16 位校验和字段：<u>对整个报文（头部和内容部分）进行循环冗余校验</u>，检验报文在传输过程中是否损坏。

**ICMP 不是严格意义上的网络层协议**，它使用处于同一层的 IP 协议提供的服务。

#### 1.1.3 传输层

为两台主机上的应用程序提供端到端（end to end）的通信。<u>只关心通信的起始端和目的端，而不在乎数据包的中转过程</u>。

<div align="center"> <img src="Figs/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B_3.png" width="700"/> </div><br>

上图中，**垂直的实线箭头表示 TCP/IP 协议族各层之间的实体通信**（数据包沿着实线传递），**水平的虚线箭头表示逻辑通信链路**。

:one: **TCP 协议**（Transmission Control Protocol，传输控制协议）：为应用层提供**可靠**的、**面向连接**的和**基于流**的服务。该协议使用<u>超时重传、数据确认</u>等方式来确保数据包被正确地发送至目的端。使用 TCP 协议通信的双方要先建立 TCP 连接，并在内核中为该连接维持一些必要的数据结构，比如连接的状态、读写缓冲区以及诸多定时器。通信结束时，双方必须关闭连接并释放这些内核数据。

:two: **UDP 协议**（User Datagram Protocol，用户数据报协议）：**不可靠**的、**无连接**和**基于数据报**的服务。如果数据在中途丢失，或者目的端通过数据校验发现数据错误而将其丢弃，则 UDP 只是通知应用程序发送失败。使用 UDP 协议的应用程序通常要自己处理数据确认、超时重传等逻辑。<u>UDP 协议的无连接</u>是指通信双方不保持一个长久的联系，因此应用程序每次发送数据都要指定接收端的地址。<u>基于数据报的服务</u>，是相对基于流的服务而言的，每个 UDP 数据报都有一个长度，接收端必须以该长度为最小单位将其所有内容一次性读出，否则数据将被截断。

:three: **SCTP 协议**（Stream Control Transmission Protocol，流控制传输协议）：旨在因特网上传输电话信号，相对较新的传输层协议。

#### 1.1.4 应用层

数据链路层、网络层和传输层负责处理**网络通信细节**，它们在**内核空间实现**。

应用层负责处理**应用程序的逻辑**，通常在**用户空间实现**。

:memo: <u>少数服务器程序在内核中实现</u>，代码无须在用户空间和内核空间来回切换（主要是数据复制），提高了工作效率。缺点是实现复杂、不便于移植。

:one: ping 应用程序：它利用 ICMP 报文检测网络连接，是调试网络环境的必备工具；（跳过传输层，直接使用网络层提供的服务）

:two: telnet 协议：远程登陆协议；

:three: OSPF 协议：动态路由更新协议，用于路由器之间的通信，告知对方各自的路由信息；（跳过传输层，直接使用网络层提供的服务）

:four: DNS 协议：提供机器域名到 IP 地址之间的转换。（既可以使用 TCP 服务，又可以使用 UDP 服务。）

可以通过 `/etc/services` 文件查看所有知名的应用层协议，以及它们能使用的传输层服务。

### 1.2 封装

上层协议使用下层协议提供的服务，通过封装实现。

<div align="center"> <img src="Figs/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B_4.png" width="700"/> </div><br>

<div align="center"> <img src="Figs/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B_5.png" width="700"/> </div><br>

当发送端应用程序使用 send 或 write 函数向 TCP 连接写入数据时，**内核中的 TCP 模块首先把这些数据复制到与该连接对应的 TCP 内核发送缓冲区中，然后 TCP 模块调用 IP 模块提供的服务**，传递的参数包括 <u>TCP 头部信息和 TCP 发送缓冲区中的数据</u>。

UDP 无须为应用层数据保存副本，**当一个 UDP 数据报成功发送之后，UDP 内核缓冲区中的该数据报就被丢弃了**。如果应用程序检测到该数据报没有被正确接收，重发数据报时，应用程序需要重新从用户空间将该数据报拷贝到 UDP 内核发送缓冲区中。

<div align="center"> <img src="Figs/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B_6.png" width="700"/> </div><br>

帧的最大传输单元（Max Transmit Unit，MTU）表示帧最多可以携带多少上层协议数据，上图中表示的以太网帧的 MTU 是1500 字节。

### 1.3 分用

**分用**：各层协议依次处理帧中本层负责的头部数据，并最终将处理后的帧交给目标应用程序。<u>分用是依靠头部信息中的类型字段实现的</u>。

<div align="center"> <img src="Figs/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B_7.png" width="700"/> </div><br>

以太网使用 2 字节的类型字段标识上层协议。

IP 数据包的头部使用 16 位的协议字段进行区分。

TCP  报文段和 UDP 数据报通过头部中的 16 位的端口号字段来区分上层应用程序。

### 1.4 测试网络

本书搭建的测试网络：

<div align="center"> <img src="Figs/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B_8.png" width="700"/> </div><br>

### 1.5 ARP 协议工作原理

**工作原理**：主机向自己所在的网络广播一个 ARP 请求，该请求包含目标机器的 <u>IP 地址</u>。此网络上的其他机器都收到这个请求，但只有被请求的目标机器会回应一个 ARP 请求，其中包含自己的<u>物理地址</u>。

#### 1.5.1 以太网 ARP 请求 / 应答报文详解

<div align="center"> <img src="Figs/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B_9.png" width="700"/> </div><br>

- 硬件类型：定义物理地址类型，值为 1 表示 MAC 地址；
- 协议类型：表示要映射的协议地址类型，值为 0x800 表示 IP 地址；
- 硬件地址长度、协议地址长度，单位为字节，对于 MAC 地址而言长度为 6，对于 IP 地址而言长度为 4；
- 操作：指示 4 种操作类型，ARP 请求（值为 1）、ARP 应答（值为 2）、RARP 请求（值为 3）、RARP 应答（值为 4）；
- 最后 4 个字段。发送端填充除目的端以太网地址外的其他 3 个字段，以构建 ARP 请求并发送。接收端发现该请求的目的端 IP 地址是自己，就把自己的以太网地址填充进去，然后交换两个目的端地址和两个发送端地址，以构建 ARP 应答并返回（其中，操作字段需要设置为 2）。

#### 1.5.2 ARP 高速缓存的查看和修改

**ARP 维护一个高速缓存**，其中包含经常访问（如网关地址）或者最近访问的机器的 IP 地址到物理地址的映射。这就**避免了重复的 ARP 请求，提高了数据包的发送速度**。

```shell
# Linux 中使用 arp 命令查看和修改 ARP 高速缓存
arp -a

# 删除一个 ARP 缓存项
sudo arp -d 192.168.1.109

# 添加一个 ARP 缓存项
sudo arp -s 192.168.1.109 08:00:27:53:10:67
```

#### 1.5.3 tcpdump 观察 ARP 通信过程

tcpdump 抓取的数据包本质上是以太网帧，该命令中（dst 和 src 指定通信的目的端 IP 地址和源端的 IP 地址）和显示（如用 -e 选项开启以太网头部信息的显示）。

<div align="center"> <img src="Figs/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B_10.png" width="700"/> </div><br>

**分析上图**：

1. 我们将两次传输的以太网帧按照图 1-6 所描述的以太网帧封装格式绘制在图的下半部分；
2. ARP 请求和应答是从以太网驱动程序发出的，而非图中描述的从 ARP 模块直接发送到以太网上，所以我们将他们用虚线表示，这主要是为了体现携带 ARP 数据的以太网帧和其他以太网帧的区别；
3. 路由器也将接收到以太网帧 1，因为该帧是一个广播帧。不过路由器并没有回应其中的 ARP 请求。

### 1.6 DNS 工作原理

**域名查询服务**：将机器的域名转换为 IP 地址，如 NIS （Network Information Service，网络信息服务）、DNS 和本地静态文件。

#### 1.6.1 DNS 查询和应答报文详解

DNS 是一套分布式的域名服务系统，每个 DNS 服务器上存放着大量的机器名和 IP 地的映射，且是动态更新的。

<div align="center"> <img src="Figs/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B_11.png" width="700"/> </div><br>

- **16 位标识**：标记一对 DNS 查询和应答，用于区分一个 DNS 应答是哪个 DNS 查询的回应；

- **16 位标志**：协商具体的通信方式和反馈通信状态，DNS 报文头部的 16 位标志字段的细节如下。

  <div align="center"> <img src="Figs/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B_12.png" width="700"/> </div><br>

  - QR：查询 / 应答标志。0——查询报文，1——应答报文；
  - opcode：定义查询和应答的类型，0——标准查询，1——反向查询（由 IP 地址获得主机域名），2——请求服务器状态；
  - AA：授权应答标志，仅由应答报文使用，1表示域名服务器是授权服务器；
  - TC：截断标志，仅当 DNS 报文使用 UDP 服务时使用。鉴于 UDP 数据报的长度限制，过长的 DNS 报文将被截断，1 表示 DNS 报文超过 512 字节，并被截断；
  - RD：递归查询标志。1——执行递归查询，即如果目标 DNS 服务器无法解析某个主机名，则它将其他 DNS 服务器继续查询，如此递归，直到获得结果并将结果返回给客服端；0——迭代查询，即如果目标 DNS 服务器无法解析某个主机名，则它将自己知道的其他 DNS 服务器的 IP 地址返回给客户端参考；
  - RA：允许递归标志。仅由应答报文使用，1表示 DNS 服务器支持递归查询；
  - zero ：未使用，设置为 0 即可；
  - rcode：4 位返回码，表示应答的状态。0——无错误，3——域名不存在；

**一般的查询报文**：包含 1 个查询问题，应答资源记录数、授权资源记录数和额外资源记录数则为 0 。应答报文的应答资源记录数则至少为 1，而授权资源记录数和额外资源记录数可为 0。



<div align="center"> <img src="Figs/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B_13.png" width="700"/> </div><br>

**查询名**封装了要查询的主机域名，**16 位查询类型**表示如何执行查询操作，常见查询类型如下：

- 类型 A：值是 1——表示获取**目标主机的 IP 地址**;
- 类型 CNAME：值是 5——表示获取**目标主机的别名**；
- 类型 PTR：值是 12——表示反向查询；

**16 位查询类**：通常值为1，表示获取 IP 地址。

应答字段、授权字段和额外信息字段都使用<u>资源记录格式</u>。

<div align="center"> <img src="Figs/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B_14.png" width="700"/> </div><br>

**32 位域名**是该记录中与资源对应的名字，其格式与查询问题中的查询名字字段相同。**16 位类型**和**16 位类**字段的含义也与 DNS 查询问题的对应字段相同。

**32 位生存时间**表示该查询记录结果可被本地客户端程序缓存多久时间（s）。

**16 位资源数据长度和资源数据**字段的内容取决于类型字段。对类型 A 而言，资源数据是 32 位的 IPV4 地址，而资源数据长度为 4。

#### 1.6.2 Linux 下访问 DNS服务

```shell
# Linux下存放DNS服务器IP地址
/etc/resolv.conf

# 访问DNS 服务器的客户端程序 host
host -t A www.baidu.com
```

`host` 命令使用 DNS 协议和 DNS 服务器通信，其 -t 选项告诉 DNS 协议使用哪种查询类型。这里我们使用 A 类型，即通过机器的域名获得其 IP 地址（实际返回的资源记录中还包括机器的别名）。

### 1.7 socket 和 TCP / IP 协议族的关系

由于数据链路层、网络层、传输层协议是在内核中实现，因此操作系统需要实现一组系统调用，使得应用程序可以访问这些协议提供的服务。

实现这组系统调用的 API 主要有两套：**socket** 和 XTI（基本不使用）。

**socket 定义的 API 提供两点功能**：

- 将应用程序数据从用户缓冲区中复制到 TCP / UDP 内核发送缓冲区，以交付内核来发送数据，或着从内核 TCP / UDP 接收缓冲区中复制数据到用户缓冲区，以读取数据；
- 应用程序可以通过他们来修改内核中各层协议的某些头部信息或其他数据结构，从而精细地控制底层通信的行为。比如，通过 setsockopt 函数来设置 IP 数据报在网络上的存活时间。

socket 是一套通用的网络编程接口，其可以访问内核中的 TCP / IP 协议栈，还可以访问其他网络协议栈（如 X.25 协议栈、UNIX 本地域协议栈）。



## 第 2 章 IP 协议详解

**本章重点**：

- <u>IP 协议头部信息</u>。IP 头部信息出现在每个 IP 数据报中，用于指定 IP 通信的源端 IP 地址、目的端 IP 地址，指导 IP 分片和重组，以及指定部分通信行为；
- <u>IP 数据报的路由和转发</u>。IP 数据报的路由和转发发生在除目标机器之外的所有主机和路由器上，它们决定数据报是否应该转发以及如何转发；

### 2.1 IP 服务的特点

IP 协议为上层协议提供无状态、无连接、不可靠的服务。

**无状态**：IP 通信双方不同步传输数据的状态信息，所有的 IP 数据报的发送、传输和接收都是相互独立、没有上下文关系的。缺点是：无法处理乱序和重复的 IP 数据报。优点是：简单、高效，无须为保持通信的状态分配内核资源，也无须每次传输数据时都携带状态信息。（UDP 协议 和 HTTP 协议都是无状态的）

> IP 数据报头部提供了一个标识字段用于唯一标识一个 IP 数据报，但其是用于处理 IP 分片和重组的，而不是用于指示接收顺序。

**无连接**：IP 通信双方都不长久地维持对方的任何信息。因此，上层协议每次发送数据时都必须明确指定对方的 IP 地址。

**不可靠**：IP 协议不保证 IP 数据报能准确到达接收端。使用 IP 服务的上层协议（如 TCP 协议）需要自己实现数据确认、超时重传等机制以达到可靠传输的目的。

### 2.2 IPv4 头部结构

#### 2.2.1 IPv4 头部结构

长度通常为 20 字节。

<div align="center"> <img src="Figs/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B_15.png" width="700"/> </div><br>

**4 位版本号**：指定 IP 协议版本。值为 4——IPv4。

**4 位头部长度**：标识该 IP 头部有多少个 32 bit 字（4 字节）。因为 4 位最大能表示 15，因此 IP 头部最长是 60 字节。

**8 位服务类型**：3 位的优先权字段 + 4 位的 TOS 字段 + 1 位保留字段（必须设置为 0）。4 位的 TOS 字段分别表示：最小延时、最大吞吐量、最高可靠性和最小费用。

**16 位总长度**：整个 IP 数据报的长度，以字节为单位。IP 数据报的最大长度为 65 535（$2^{16}-1$）字节。长度超过 MTU 的数据报都被分片传输，所以实际传输的 IP 数据报的长度远没有达到最大值。

**16 位标识**：唯一标识主机发送的每一个数据报。初始值由系统随机生成，每发送一个数据报，其值加 1。该值在数据分片时被复制到每个分片中，因此同一个数据报的所有分片具有相同的标识值。

**3 位标志字段**：第一位保留，第二位表示"禁止分片"，此时如果 IP 数据报长度超过 MTU 的话，IP 模块将丢弃该数据报并返回一个 ICMP 差错报文。第三位表示"更多分片"，除了数据报的最后一个分片外，其他分片都要将它置为1。

**13 位分片偏移**：分片相对原始 IP 数据报开始处的偏移（仅指数据部分），实际的偏移值是该值左移 3 位（乘以 8）后得到。除最后一个 IP 分片之外，每个 IP 分片的数据部分长度必须是 8 的整数倍。

**8 位生存时间 TTL**：数据包到达目的地之前允许经过的路由器跳数。发送端一般将其设置为 64，数据报在转发过程中每经过一个路由，该值就被路由器减 1。当 TTL 值减为 0 时，路由器就丢弃数据报，并向源端发送一个 ICMP 差错报文。

**8 位协议**：区分上层协议。1——ICMP，6 ——TCP，17——UDP。

**16 位头部校验和**：发送端填充，接收端对其使用 CRC 算法以检验 IP 数据报头部在传输过程中是否损坏。

**32 位的源端 IP 地址和目的端 IP 地址**：用来标识数据报的发送端和接收端。

**可变长的可选信息**：这部分最多包含 40 字节，因为 IP 头部最长是 60 字节。可用的 IP 选项包括：记录路由、时间戳、松散源路由选择、严格源路由选择。

### 2.3 IP 分片

 IP 数据报的长度超过帧的 MTU 时，它将被分片传输，分片可能发生在发送端、中转路由器上，也可能在传输过程中被多次分片。

IP 头部中的三个字段：数据报标识、标志和片偏移。

<div align="center"> <img src="Figs/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B_16.png" width="700"/> </div><br>

### 2.4 IP 路由

<u>数据报的路由</u>是 IP 协议的核心任务，其决定发送数据报到目标机器的路径。

#### 2.4.1 IP 模块工作流程

<div align="center"> <img src="Figs/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B_17.png" width="700"/> </div><br>

**从右往左分析**：

- 当 IP 模块收到来自数据链路层的 IP 数据报时，其首先对该数据报的头部做 CRC 校验，确认无误后分析其头部的具体信息。
- 若该 IP 数据报的头部设置了源站选路选项，则 IP 模块调用数据报转发子模块来处理该数据报。若该 IP 数据报的头部中目标 IP 地址是本机的某个 IP 地址，或者广播地址，即该数据报是发送给本机的，则 IP 模块就根据数据报头部中的协议字段来决定将它发给哪个上层应用。
- IP 输出队列中存放的是所有等待发送的 IP 数据报，其中除了需要转发的 IP 数据报之外，还包括封装了本机上层数据的 IP 数据报。
- 图中虚线箭头显示了路由表更新的过程，这一过程是指通过路由协议或者 route 命令调整路由表，使其适应最新的网络拓扑结构，称为 IP 路由策略。

#### 2.4.2 路由机制

```shell
# 查看路由表
route
netstat
```

<div align="center"> <img src="Figs/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B_18.png" width="700"/> </div><br>

<div align="center"> <img src="Figs/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B_19.png" width="700"/> </div><br>

**:star: IP 的路由机制**：

- 查找路由表中和数据报的目标 IP 地址完全匹配的主机 IP 地址，如果找到就使用该路由项。没有则转到步骤 2。
- 查找路由表中和数据报的目标 IP 地址具有相同网路 ID 的网络 IP 地址。如果找到就使用该路由项，没有找到就转到步骤3；
- 选择默认路由项，通常是网关。

#### 2.4.2 路由机制

通过 route 命令或者其他工具手动修改路由表是静态的路由更新方式；对于大型的路由器，它们常通过 BGP 、RIP 、OSPF 等协议来发现路径，并更新自己的路由表，这种更新方式是动态的、自动的。

### 2.5 IP 转发

路由器能执行数据报的转发操作，而主机一般只能发送和接收数据报，这是因为主机上 `/proc/sys/net/ipv4/ip_forward` 内核参数默认被设置为 0。我们可以通过修改它来使能主机的数据报转发功能：

```shell
# echo 1 > /proc/sys/net/ipv4/ip_forward
```

数据报转发子模块对于期望转发的数据报执行如下操作：

- 检查数据报头部的 TTL 值，如果 TTL 值已经是 0，则丢弃该数据报；
- 查看数据报头部的严格源路由选择选项。如果该选项被设置，则检测数据报的目标 IP 地址是否为本机的某个 IP 地址，如果不是则发送一个 ICMP 源站选路失败报文给发送端。
- 如果有必要，则给源端发送一个 ICMP 重定向报文，告诉它一个更合理的下一跳路由器；
- 将 TTL 值减1；
- 处理 IP 头部选项；
- 如果有必要的话，就执行 IP 分片操作；

###  2.6 重定向

####  2.6.1 ICMP 重定向报文

<div align="center"> <img src="Figs/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B_20.png" width="700"/> </div><br>

​	ICMP 重定向报文的类型值是 5，代码字段有 4 个可选值，用于区分不同的重定向类型。主机重定向代码值 为 1。ICMP 重定向报文的数据部分提供了两个信息：

- 引起重定向的 IP 数据报的源端 IP 地址；
- 应该使用的路由器的 IP 地址；

`/proc/sys/net/ipv4/conf/all/send_redirects` 内核参数指定是否允许发送 ICMP 重定向报文，`/proc/sys/net/ipv4/conf/all/accept_redirects` 内核参数指定是否允许接收 ICMP 重定向报文。主机一般只能接收 ICMP 重定向报文，而路由器只能发送 ICMP 重定向报文。

###  2.7 IPv6 头部结构

IPv6 不仅解决了 IPv4 地址不够用的问题，还增加了多播和流的功能，为网络上多媒体内容的质量提供精细的控制；引入了自动配置功能，使局域网管理更方便；增加了专门的网络安全功能。

####  2.7.1 IPv6 固定头部结构

IPv6 头部由 <u>40 字节的固定头部</u>和<u>可变长的扩展头部</u>组成。

<div align="center"> <img src="Figs/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B_21.png" width="700"/> </div><br>

**4 位版本号**：指定 IP 协议版本，值为 6 —— IPv6；

**8 位通信类型**：指示数据流通信类型或优先级，和 IPv4 中的 TOS 类似；

**20 位流标签**：IPv6 新增字段，用于某些对连接的服务质量特殊要求的通信；

**16 位净荷长度**：IPv6 扩展头部和应用程序数据长度之和，不包括固定头部长度；

**8 位下一个包头**： 指出紧跟 IPv6 固定头部后的包头类型，如扩展头或者某个上层协议头；

**8 位跳数限制**：和 IPv4 中的 TTL 含义相同；

IPv6 地址使用 " : " 分割为 8 组，每组包含 2 字节。**零压缩法**可以将其简写，也就是省略连续的、全零的组。不过零压缩法对一个 IPv6 地址只能使用一次。

####  2.7.2 IPv6 扩展头部

可变长的扩展头部使得 IPv6 能支持更多的选项，并且很便于将来的扩展需要。一个数据报可以包含多个扩展头部，每个扩展头部的类型是由前一个头部中的下一个报文字段指定。

<div align="center"> <img src="Figs/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B_22.png" width="700"/> </div><br>



## 第 3 章 TCP 协议详解

- TCP 头部信息。TCP 头部信息出现于每个 TCP 报文段中，用于指定通信的源端口号、目的端口号，管理 TCP 连接，控制两个方向的数据流；
- TCP 状态转移过程，TCP 连接的任意一端都是一个状态机，TCP 连接从建立到断开的过程中，连接两端的状态机将经历不同的状态变迁。
- TCP 数据流。分析 TCP 数据流，从网络应用程序外部来了解应用层协议和通信双方交换的应用程序数据。TCP 数据流：交互数据流、成块数据流、紧急数据流。
- TCP 数据流的控制。为保证可靠传输和提供网络通信质量，内核需要对 TCP 数据流进行控制。

### 3.1 TCP 服务的特点

TCP 协议相对于 UDP 协议的特点：面向连接、字节流和可靠传输。

- **面向连接**：使用 TCP 协议通信的双方必须先建立连接，然后开始数据的读写。双方都必须为该连接分配必要的内核资源，以管理连接的状态和连接上数据的传输。TCP 连接是全双工的，双方的数据读写可以通过一个连接进行，完成数据交换之后，通信双方必须断开连接释放系统资源。这种连接是一对一的，不适用于广播和多播的应用。而无连接的 UDP 非常适合用于广播和多播。
- **字节流**：发送端执行的写操作次数和接收端执行的读操作次数之间没有任何数量关系，应用程序对于数据的发送和接收没有边界限制。
- **可靠传输**：TCP 协议采用<u>发送应答</u>机制，发送端发送的每个 TCP 报文段都必须得到接收方的应答，才认为这个 TCP 报文段传输成功。TCP 协议还采用超时重传机制，发送端在发送出一个 TCP 报文段之后启动定时器，如果在定时时间内未收到应答，它将重发该报文段。TCP 报文段最终是以 IP 数据报发送的，而 IP 数据报到达接收端可能乱序、重复，所以 TCP 协议还会对接收到的 TCP 报文段重排、整理，再交付给应用层。

### 3.2 TCP 头部结构

固定头部结构 + 头部选项

#### 3.2.1 TCP 固定头部结构

<div align="center"> <img src="Figs/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B_23.png" width="700"/> </div><br>

**16 位端口号**：告知主机该报文段的源端口以及传给哪个目的端口。进行 TCP 通信时，客户端通常使用系统自动选择的临时端口号，服务器则使用知名服务端口号。

**32 位序号**：一次 TCP 通信（从 TCP 连接建立到断开）过程中某个传输方向上的字节流的每个字节的编号。首次通信时，发送方发送的第一个 TCP 报文段中，序号值被系统初始化为某个随机值 ISN （初始序号值）。那么在该传输方向上，后续的 TCP 报文段中的序号值将被系统设置为 ISN 加上该报文段所携带数据的第一个字节在整个字节流中的偏移。如某个 TCP 报文段传送的数据是字节流中的第 1025 ~ 2048 字节，那么该报文段的序号值就是 ISN + 1025。另外一个传输方向的 TCP 报文段的序号值也具有相同的含义。

**32 位确认号**：对另一方发送来的 TCP 报文段的响应。值为收到的 TCP 报文段的序号值加1。

**4 位头部长度**：标识该 TCP 头部有多少个 32 bit 字（4 字节）。最大能表示 15，TCP 头部最长是 60 字节。

**6 位标志位**：

- URG 标志：紧急指针是否有效；
- ACK 标志：确认号是否有效，携带 ACK 标志的 TCP 报文段为确认报文段；
- PSH 标志：提示接收端应用程序应该立即从 TCP 缓冲区中读走数据，为接收后续数据腾出空间；
- RST 标志：表示要求对方重新建立连接，携带 RST 标志的 TCP 报文段为<u>复位报文段</u>；
- SYN 标志：表示请求建立连接，携带 SYN 标志的 TCP 报文段为<u>同步报文段</u>；
- FIN 标志：通知对方本端要关闭连接，携带 FIN 标志的 TCP 报文段为<u>结束报文段</u>；

**16 位窗口大小**：TCP 流量控制的手段，这里的窗口是接收通告窗口，其告诉对方本端的 TCP 接收缓冲区还能容纳多少字节的数据。

**16 位校验和**：由发送端填充，接收端对 TCP 报文段执行 CRC 算法以检验 TCP 报文段在传输过程中是否损坏。这里的校验包括 TCP 头部以及数据部分。

**16 位紧急指针**：一个正的偏移量，它和序号字段的值相加表示最后一个紧急数据的下一个字节的序号。因此，这个字段是紧急指针相对当前序号的偏移，不妨称之为紧急偏移。TCP 紧急指针就是发送端向接收端发送紧急数据的方法。

#### 3.2.2 TCP 头部选项

TCP 头部最后一个选项字段是可变长的可选信息。

<div align="center"> <img src="Figs/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B_24.png" width="700"/> </div><br>

kind 值说明：

- 值为 0：选项表结束选项；

- 值为 1：空操作选项，无特殊含义，一般用于将 TCP 选项的总长度填充为 4 字节的整数倍；

- 值为 2：最大报文段长度选项。TCP 连接初始化时，通信双方使用该选项协商最大报文段长度。TCP 模块常设置 MSS 为 MTU - 40 字节，其中减去的 40 字节包括了20 字节的 TCP 头部和 20 字节的 IP 头部。

- 值为 3：窗口扩大因子选项。TCP 头部中，接收通告窗口大小用 16 位表示，最大为 65535 字节，实际上 TCP 模块允许的接收通告窗口大小远不止这个数。假设 TCP 头部中的接收通告窗口大小是 N ，窗口扩大因子（移位数）为 M，则 TCP 报文段的实际接收通告窗口大小是 N 乘以 $2^M$ ，也就是 N 左移 M 位。

  ```shell
  # 修改内核变量来启动或关闭窗口扩大因子选项
  /proc/sys/net/ipv4/tcp_window_scaling
  ```

- 值为 4：选择性确认（SACK）选项。SACK 技术使得 TCP 模块只能重新发送丢失的 TCP 报文段，不用发送所有未被确认的 TCP 报文段。

  ```shell
  # 修改内核变量来启动或关闭选择性确认选项
  /proc/sys/net/ipv4/tcp_sack
  ```

- 值为 5：SACK 实际工作的选项，该选项的参数告诉发送方本端已经收到并缓存的不连续的数据块，从而让发送端可以据此检查并重发丢失的数据块。

- 值为 8：时间戳选项。该选项提供了较准确的计算通信双方之间的回路时间的方法，从而为 TCP 流量控制提供重要信息。

  ```shell
  # 修改内核变量来启动或关闭时间戳选项
  /proc/sys/net/ipv4/tcp_timestamps
  ```

  

### 3.3 TCP 连接的建立和关闭

一般而言，TCP 连接是由客户端发起，并通过三次握手建立。TCP 连接的关闭可能是客户端执行主动关闭，也可能是服务端执行主动关闭，比如服务器程序被中断而强制关闭连接，还可能是同时关闭。

#### 3.3.2 半关闭状态

TCP 连接半关闭状态：TCP 通信的一方可以发送结束报文段给对方，告诉它本端已经完成了数据的发送，但是允许继续接收来自对方的数据，直到对方也发送结束报文段以关闭连接。

#### 3.3.3 连接超时

TCP 模块一共执行 5 次重连操作，这是由

```shell
/proc/sys/net/ipv4/tcp_syn_retries # 内核变量定义
```

每次重连的超时时间都增加 1 倍，在 5 次重连均失败的情况下，TCP 模块放弃连接并通知应用程序。

### 3.4 TCP 状态转移

<div align="center"> <img src="Figs/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B_25.png" width="700"/> </div><br>

**服务器的典型状态转移过程：**

服务器通过 listen 系统调用进入 LISTEN 状态，被动等待客户端连接，因此执行的是所谓的被动打开。服务器一旦监听到某个连接请求（收到同步报文段），就将该连接放入内核等待队列中，并向客户端发送带 SYN 标志的确认报文段。此时该连接出于 SYN_RCVD 状态。如果服务器成功收到客户端发送回的确认报文段，则该连接转移到 ESTABLISHED 状态。**ESTABLISHED 状态** 是连接双方能够进行双向数据传输的状态。

当客户端主动关闭连接时（通过 close 或 shutdown 系统调用向服务器发送结束报文段），服务器通过返回确认报文段使连接进入 CLOSE_WAIT 状态。**CLOSE_WAIT 状态**就是等待服务器应用程序关闭连接，通常服务器检测到客户端关闭连接后，也会立即给客户端发送一个结束报文段来关闭连接。这就使得连接状态转移到 LAST_ACK 状态，以等待客户端对结束报文段的最后一次确认。



**客户端的典型状态转移过程：**

客户端通过 connect 系统调用主动与服务器建立连接。connect 系统调用首先给服务器发送一个同步报文段，使连接转移到 SYN_SENT 状态。此后，connect 系统调用可能因为如下两个原因失败返回：

- 如果 connect 连接的目标端口不存在，或者该端口仍处于 TIME_WAIT 状态的连接所占用，则服务器将给客户端发送一个复位报文段，connect 调用失败。
- 如果目标端口存在，但 connect 在超时时间内未收到服务器的确认报文段，则 connect 调用失败。

connect 调用失败则连接立即返回到初始的 CLOSED 状态，如果客户端成功收到服务器的同步报文段和确认，则 connect 调用成功返回，连接转移到 ESTABLISHED 状态。

当客户端执行主动关闭时，它将向服务器发送一个结束报文段，同时连接进入 FIN_WAIT_1 状态。若此时客户端收到服务器专门用于确认目的的确认报文段，则转移到 FIN_WAIT_2 状态。当客户端处于 FIN_WAIT_2 状态时，服务器处于 CLOSE_WAIT 状态，这一对状态是可能发生半关闭的状态。此时如果服务器也关闭连接，则客户端将给予确认并进入 TIME_WAIT 状态。



连续停留在 FIN_WAIT_2 状态的情况可能发生在：客户端执行半关闭后，未等服务器关闭连接就强行退出了。此时客户端连接将有内核来接管，这就是**孤儿连接**。Linux 为了防止孤儿连接长时间存留在内核中，定义了两个内核变量：

```shell
/proc/sys/net/ipv4/tcp_max_orphans		# 指定内核能接管的孤儿连接数
/proc/sys/net/ipv4/tcp_fin_timeout		# 指定孤儿连接在内核中生存的时间
```

<div align="center"> <img src="Figs/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B_26.png" width="700"/> </div><br>

### 3.5 复位报文段

#### 3.5.1 访问不存在的端口

客户端程序访问一个不存在的端口时，目标主机将给它发送一个 RST 报文段。

由于复位报文段的接收通告窗口大小为 0，收到复位报文段的一端应该关闭连接或者重新连接，而不能回应这个复位报文段。

当客户端程序向服务器的某个端口发起连接，而该端口仍然出于 TIME_WAIT 状态的连接所占用时，客户端程序也将收到复位报文段。

#### 3.5.2 异常终止连接

TCP 提供了异常终止一个连接的方法，即给对方发送一个复位报文段。一旦发送了复位报文段，发送端所有排队等待发送的数据都将被丢弃。

应用程序可以使用 socket 选项 SO_LINGER 来发送复位报文段，以异常终止一个连接。

#### 3.5.3 处理半打开连接

**半打开状态**：服务器（或客户端）关闭或者异常终止了连接，而对方没有收到结束报文段，此时客户端（或服务器）还维持着原来的连接，而服务器（或客户端）即使重启也没有该连接的任何信息。<u>处于这种状态的连接称为半打开连接</u>。

### 3.6 TCP 交互数据流

TCP 报文段所携带应用程序数据按照长度分为：交互数据和成块数据。

- 交互数据仅包含很少的字节，使用交互数据的应用程序对于实时性要求高，如telnet、ssh。

- 成块数据的长度则通常为 TCP 报文段允许的最大数据长度，使用成块数据的应用程序对传输效率要求较高，如ftp。























## 第 4 章 TCP / IP 通信案例：访问 Internet 上的 Web服务器





