提高服务器程序性能的一般原则：

- 使用 “池” 以牺牲空间换取效率；
- 使用零拷贝函数以避免内核和用户空间的切换；
- 高效的编程模式及其应用：使用有限状态机来分析用户数据，使用进程池或线程池来处理用户请求；
- 调整系统参数来从服务器程序外部提高其整体性能。

实例：第15章 利用进程池实现的简单 CGI 服务器和用线程池实现的简单 Web 服务器。

作者写的负载均衡服务器程序 springsnail ，该程序从所有逻辑服务器中选取负荷最小的一台来处理新到的客户连接。这个程序中，使用了进程池、有限状态机、高效的数据结构来提高性能；同时，封装了每个函数和模块，使其符合实际工程项目。

[TOC]



# 第一篇 TCP/IP 协议详解

理解底层 TCP / IP 通信过程。

## 第 1 章 TCP/IP 协议族

后续详解 IP 协议以及 TCP 协议，本章讨论 ICMP、ARP、DNS 协议。

### 1.1 TCP/IP 协议族体系结构以及主要协议

TCP/IP 协议族：一个四层协议系统，**下层协议为上层协议提供服务**。



<div align="center"> <img src="Figs/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B_1.png" width="700"/> </div><br>

#### 1.1.1 数据链路层

实现网卡接口的网络驱动程序，以处理数据在物理媒介上的传输。

**ARP 协议**（Address Resolve Protocol，地址解析协议）：IP 地址转换为 MAC 地址；

- 网络层使用 IP 地址寻址机器，数据链路层使用 MAC 地址寻址机器，因此网络层要将目标机器的 IP 地址转化为 MAC 地址，才能使用数据链路层提供的服务。

**RARP 协议** （Reverse Address Resolve Protocol，逆地址解析协议）。

- 无盘工作站缺少存储设备，无法记住自己的 IP 地址，但它们利用网卡上的 MAC 地址向服务器查询自身的 IP 地址。（运行 RARP 服务的服务器上存有该网络上所有机器的 MAC 地址到 IP 地址的映射。）

#### 1.1.2 网络层

实现数据包的选路和转发。网络层对上层协议隐藏了网络拓扑连接的细节，使得在传输层和网络应用程序看来，通信双方是直接相连的。

**ICMP 协议**（Internet Control Message Protocol，因特网控制报文协议）：用于检测网络连接，其使用的报文格式如下：

<div align="center"> <img src="Figs/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B_2.png" width="700"/> </div><br>

- 8 位类型字段：<u>区分报文类型</u>。其将 ICMP 报文分为两类，一类是用于回应网络错误的**差错报文**，如目标不可达（类型值为 3）和重定向（类型值为 5）；另一类是用于查询网络信息的**查询报文**，如 ping 程序就是用 ICMP 报文查看目标是否可达（类型值为 8）。
- 8 位代码字段：进一步细分不同的条件，如重定向报文使用代码值 0 表示对网络重定向，代码值 1 表示对主机重定向。
- 16 位校验和字段：<u>对整个报文（头部和内容部分）进行循环冗余校验</u>，检验报文在传输过程中是否损坏。

**ICMP 不是严格意义上的网络层协议**，它使用处于同一层的 IP 协议提供的服务。

#### 1.1.3 传输层

为两台主机上的应用程序提供端到端（end to end）的通信。<u>只关心通信的起始端和目的端，而不在乎数据包的中转过程</u>。

<div align="center"> <img src="Figs/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B_3.png" width="700"/> </div><br>

上图中，**垂直的实线箭头表示 TCP/IP 协议族各层之间的实体通信**（数据包沿着实线传递），**水平的虚线箭头表示逻辑通信链路**。

:one: **TCP 协议**（Transmission Control Protocol，传输控制协议）：为应用层提供**可靠**的、**面向连接**的和**基于流**的服务。该协议使用<u>超时重传、数据确认</u>等方式来确保数据包被正确地发送至目的端。使用 TCP 协议通信的双方要先建立 TCP 连接，并在内核中为该连接维持一些必要的数据结构，比如连接的状态、读写缓冲区以及诸多定时器。通信结束时，双方必须关闭连接并释放这些内核数据。

:two: **UDP 协议**（User Datagram Protocol，用户数据报协议）：**不可靠**的、**无连接**和**基于数据报**的服务。如果数据在中途丢失，或者目的端通过数据校验发现数据错误而将其丢弃，则 UDP 只是通知应用程序发送失败。使用 UDP 协议的应用程序通常要自己处理数据确认、超时重传等逻辑。<u>UDP 协议的无连接</u>是指通信双方不保持一个长久的联系，因此应用程序每次发送数据都要指定接收端的地址。<u>基于数据报的服务</u>，是相对基于流的服务而言的，每个 UDP 数据报都有一个长度，接收端必须以该长度为最小单位将其所有内容一次性读出，否则数据将被截断。

:three: **SCTP 协议**（Stream Control Transmission Protocol，流控制传输协议）：旨在因特网上传输电话信号，相对较新的传输层协议。

#### 1.1.4 应用层

数据链路层、网络层和传输层负责处理**网络通信细节**，它们在**内核空间实现**。

应用层负责处理**应用程序的逻辑**，通常在**用户空间实现**。

:memo: <u>少数服务器程序在内核中实现</u>，代码无须在用户空间和内核空间来回切换（主要是数据复制），提高了工作效率。缺点是实现复杂、不便于移植。

:one: ping 应用程序：它利用 ICMP 报文检测网络连接，是调试网络环境的必备工具；（跳过传输层，直接使用网络层提供的服务）

:two: telnet 协议：远程登陆协议；

:three: OSPF 协议：动态路由更新协议，用于路由器之间的通信，告知对方各自的路由信息；（跳过传输层，直接使用网络层提供的服务）

:four: DNS 协议：提供机器域名到 IP 地址之间的转换。（既可以使用 TCP 服务，又可以使用 UDP 服务。）

可以通过 `/etc/services` 文件查看所有知名的应用层协议，以及它们能使用的传输层服务。

### 1.2 封装

上层协议使用下层协议提供的服务，通过封装实现。

<div align="center"> <img src="Figs/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B_4.png" width="700"/> </div><br>

<div align="center"> <img src="Figs/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B_5.png" width="700"/> </div><br>

当发送端应用程序使用 send 或 write 函数向 TCP 连接写入数据时，**内核中的 TCP 模块首先把这些数据复制到与该连接对应的 TCP 内核发送缓冲区中，然后 TCP 模块调用 IP 模块提供的服务**，传递的参数包括 <u>TCP 头部信息和 TCP 发送缓冲区中的数据</u>。

UDP 无须为应用层数据保存副本，**当一个 UDP 数据报成功发送之后，UDP 内核缓冲区中的该数据报就被丢弃了**。如果应用程序检测到该数据报没有被正确接收，重发数据报时，应用程序需要重新从用户空间将该数据报拷贝到 UDP 内核发送缓冲区中。

<div align="center"> <img src="Figs/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B_6.png" width="700"/> </div><br>

帧的最大传输单元（Max Transmit Unit，MTU）表示帧最多可以携带多少上层协议数据，上图中表示的以太网帧的 MTU 是1500 字节。

### 1.3 分用

**分用**：各层协议依次处理帧中本层负责的头部数据，并最终将处理后的帧交给目标应用程序。<u>分用是依靠头部信息中的类型字段实现的</u>。

<div align="center"> <img src="Figs/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B_7.png" width="700"/> </div><br>

以太网使用 2 字节的类型字段标识上层协议。

IP 数据包的头部使用 16 位的协议字段进行区分。

TCP  报文段和 UDP 数据报通过头部中的 16 位的端口号字段来区分上层应用程序。

### 1.4 测试网络

本书搭建的测试网络：

<div align="center"> <img src="Figs/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B_8.png" width="700"/> </div><br>

### 1.5 ARP 协议工作原理

**工作原理**：主机向自己所在的网络广播一个 ARP 请求，该请求包含目标机器的 <u>IP 地址</u>。此网络上的其他机器都收到这个请求，但只有被请求的目标机器会回应一个 ARP 请求，其中包含自己的<u>物理地址</u>。

#### 1.5.1 以太网 ARP 请求 / 应答报文详解

<div align="center"> <img src="Figs/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B_9.png" width="700"/> </div><br>

- 硬件类型：定义物理地址类型，值为 1 表示 MAC 地址；
- 协议类型：表示要映射的协议地址类型，值为 0x800 表示 IP 地址；
- 硬件地址长度、协议地址长度，单位为字节，对于 MAC 地址而言长度为 6，对于 IP 地址而言长度为 4；
- 操作：指示 4 种操作类型，ARP 请求（值为 1）、ARP 应答（值为 2）、RARP 请求（值为 3）、RARP 应答（值为 4）；
- 最后 4 个字段。发送端填充除目的端以太网地址外的其他 3 个字段，以构建 ARP 请求并发送。接收端发现该请求的目的端 IP 地址是自己，就把自己的以太网地址填充进去，然后交换两个目的端地址和两个发送端地址，以构建 ARP 应答并返回（其中，操作字段需要设置为 2）。

#### 1.5.2 ARP 高速缓存的查看和修改

**ARP 维护一个高速缓存**，其中包含经常访问（如网关地址）或者最近访问的机器的 IP 地址到物理地址的映射。这就**避免了重复的 ARP 请求，提高了数据包的发送速度**。

```shell
# Linux 中使用 arp 命令查看和修改 ARP 高速缓存
arp -a

# 删除一个 ARP 缓存项
sudo arp -d 192.168.1.109

# 添加一个 ARP 缓存项
sudo arp -s 192.168.1.109 08:00:27:53:10:67
```

#### 1.5.3 tcpdump 观察 ARP 通信过程

tcpdump 抓取的数据包本质上是以太网帧，该命令中（dst 和 src 指定通信的目的端 IP 地址和源端的 IP 地址）和显示（如用 -e 选项开启以太网头部信息的显示）。

<div align="center"> <img src="Figs/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B_10.png" width="700"/> </div><br>

**分析上图**：

1. 我们将两次传输的以太网帧按照图 1-6 所描述的以太网帧封装格式绘制在图的下半部分；
2. ARP 请求和应答是从以太网驱动程序发出的，而非图中描述的从 ARP 模块直接发送到以太网上，所以我们将他们用虚线表示，这主要是为了体现携带 ARP 数据的以太网帧和其他以太网帧的区别；
3. 路由器也将接收到以太网帧 1，因为该帧是一个广播帧。不过路由器并没有回应其中的 ARP 请求。

### 1.6 DNS 工作原理

**域名查询服务**：将机器的域名转换为 IP 地址，如 NIS （Network Information Service，网络信息服务）、DNS 和本地静态文件。

#### 1.6.1 DNS 查询和应答报文详解

DNS 是一套分布式的域名服务系统，每个 DNS 服务器上存放着大量的机器名和 IP 地的映射，且是动态更新的。

<div align="center"> <img src="Figs/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B_11.png" width="700"/> </div><br>

- **16 位标识**：标记一对 DNS 查询和应答，用于区分一个 DNS 应答是哪个 DNS 查询的回应；

- **16 位标志**：协商具体的通信方式和反馈通信状态，DNS 报文头部的 16 位标志字段的细节如下。

  <div align="center"> <img src="Figs/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B_12.png" width="700"/> </div><br>

  - QR：查询 / 应答标志。0——查询报文，1——应答报文；
  - opcode：定义查询和应答的类型，0——标准查询，1——反向查询（由 IP 地址获得主机域名），2——请求服务器状态；
  - AA：授权应答标志，仅由应答报文使用，1表示域名服务器是授权服务器；
  - TC：截断标志，仅当 DNS 报文使用 UDP 服务时使用。鉴于 UDP 数据报的长度限制，过长的 DNS 报文将被截断，1 表示 DNS 报文超过 512 字节，并被截断；
  - RD：递归查询标志。1——执行递归查询，即如果目标 DNS 服务器无法解析某个主机名，则它将其他 DNS 服务器继续查询，如此递归，直到获得结果并将结果返回给客服端；0——迭代查询，即如果目标 DNS 服务器无法解析某个主机名，则它将自己知道的其他 DNS 服务器的 IP 地址返回给客户端参考；
  - RA：允许递归标志。仅由应答报文使用，1表示 DNS 服务器支持递归查询；
  - zero ：未使用，设置为 0 即可；
  - rcode：4 位返回码，表示应答的状态。0——无错误，3——域名不存在；

**一般的查询报文**：包含 1 个查询问题，应答资源记录数、授权资源记录数和额外资源记录数则为 0 。应答报文的应答资源记录数则至少为 1，而授权资源记录数和额外资源记录数可为 0。



<div align="center"> <img src="Figs/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B_13.png" width="700"/> </div><br>

**查询名**封装了要查询的主机域名，**16 位查询类型**表示如何执行查询操作，常见查询类型如下：

- 类型 A：值是 1——表示获取**目标主机的 IP 地址**;
- 类型 CNAME：值是 5——表示获取**目标主机的别名**；
- 类型 PTR：值是 12——表示反向查询；

**16 位查询类**：通常值为1，表示获取 IP 地址。

应答字段、授权字段和额外信息字段都使用<u>资源记录格式</u>。

<div align="center"> <img src="Figs/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B_14.png" width="700"/> </div><br>

**32 位域名**是该记录中与资源对应的名字，其格式与查询问题中的查询名字字段相同。**16 位类型**和**16 位类**字段的含义也与 DNS 查询问题的对应字段相同。

**32 位生存时间**表示该查询记录结果可被本地客户端程序缓存多久时间（s）。

**16 位资源数据长度和资源数据**字段的内容取决于类型字段。对类型 A 而言，资源数据是 32 位的 IPV4 地址，而资源数据长度为 4。

#### 1.6.2 Linux 下访问 DNS服务

```shell
# Linux下存放DNS服务器IP地址
/etc/resolv.conf

# 访问DNS 服务器的客户端程序 host
host -t A www.baidu.com
```

`host` 命令使用 DNS 协议和 DNS 服务器通信，其 -t 选项告诉 DNS 协议使用哪种查询类型。这里我们使用 A 类型，即通过机器的域名获得其 IP 地址（实际返回的资源记录中还包括机器的别名）。

### 1.7 socket 和 TCP / IP 协议族的关系

由于数据链路层、网络层、传输层协议是在内核中实现，因此操作系统需要实现一组系统调用，使得应用程序可以访问这些协议提供的服务。

实现这组系统调用的 API 主要有两套：**socket** 和 XTI（基本不使用）。

**socket 定义的 API 提供两点功能**：

- 将应用程序数据从用户缓冲区中复制到 TCP / UDP 内核发送缓冲区，以交付内核来发送数据，或着从内核 TCP / UDP 接收缓冲区中复制数据到用户缓冲区，以读取数据；
- 应用程序可以通过他们来修改内核中各层协议的某些头部信息或其他数据结构，从而精细地控制底层通信的行为。比如，通过 setsockopt 函数来设置 IP 数据报在网络上的存活时间。

socket 是一套通用的网络编程接口，其可以访问内核中的 TCP / IP 协议栈，还可以访问其他网络协议栈（如 X.25 协议栈、UNIX 本地域协议栈）。



## 第 2 章 IP 协议详解

**本章重点**：

- <u>IP 协议头部信息</u>。IP 头部信息出现在每个 IP 数据报中，用于指定 IP 通信的源端 IP 地址、目的端 IP 地址，指导 IP 分片和重组，以及指定部分通信行为；
- <u>IP 数据报的路由和转发</u>。IP 数据报的路由和转发发生在除目标机器之外的所有主机和路由器上，它们决定数据报是否应该转发以及如何转发；

### 2.1 IP 服务的特点

IP 协议为上层协议提供无状态、无连接、不可靠的服务。

**无状态**：IP 通信双方不同步传输数据的状态信息，所有的 IP 数据报的发送、传输和接收都是相互独立、没有上下文关系的。缺点是：无法处理乱序和重复的 IP 数据报。优点是：简单、高效，无须为保持通信的状态分配内核资源，也无须每次传输数据时都携带状态信息。（UDP 协议 和 HTTP 协议都是无状态的）

> IP 数据报头部提供了一个标识字段用于唯一标识一个 IP 数据报，但其是用于处理 IP 分片和重组的，而不是用于指示接收顺序。

**无连接**：IP 通信双方都不长久地维持对方的任何信息。因此，上层协议每次发送数据时都必须明确指定对方的 IP 地址。

**不可靠**：IP 协议不保证 IP 数据报能准确到达接收端。使用 IP 服务的上层协议（如 TCP 协议）需要自己实现数据确认、超时重传等机制以达到可靠传输的目的。

### 2.2 IPv4 头部结构

#### 2.2.1 IPv4 头部结构

长度通常为 20 字节。

<div align="center"> <img src="Figs/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B_15.png" width="700"/> </div><br>

**4 位版本号**：指定 IP 协议版本。值为 4——IPv4。

**4 位头部长度**：标识该 IP 头部有多少个 32 bit 字（4 字节）。因为 4 位最大能表示 15，因此 IP 头部最长是 60 字节。

**8 位服务类型**：3 位的优先权字段 + 4 位的 TOS 字段 + 1 位保留字段（必须设置为 0）。4 位的 TOS 字段分别表示：最小延时、最大吞吐量、最高可靠性和最小费用。

**16 位总长度**：整个 IP 数据报的长度，以字节为单位。IP 数据报的最大长度为 65 535（$2^{16}-1$）字节。长度超过 MTU 的数据报都被分片传输，所以实际传输的 IP 数据报的长度远没有达到最大值。

**16 位标识**：唯一标识主机发送的每一个数据报。初始值由系统随机生成，每发送一个数据报，其值加 1。该值在数据分片时被复制到每个分片中，因此同一个数据报的所有分片具有相同的标识值。

**3 位标志字段**：第一位保留，第二位表示"禁止分片"，此时如果 IP 数据报长度超过 MTU 的话，IP 模块将丢弃该数据报并返回一个 ICMP 差错报文。第三位表示"更多分片"，除了数据报的最后一个分片外，其他分片都要将它置为1。

**13 位分片偏移**：分片相对原始 IP 数据报开始处的偏移（仅指数据部分），实际的偏移值是该值左移 3 位（乘以 8）后得到。除最后一个 IP 分片之外，每个 IP 分片的数据部分长度必须是 8 的整数倍。

**8 位生存时间 TTL**：数据包到达目的地之前允许经过的路由器跳数。发送端一般将其设置为 64，数据报在转发过程中每经过一个路由，该值就被路由器减 1。当 TTL 值减为 0 时，路由器就丢弃数据报，并向源端发送一个 ICMP 差错报文。

**8 位协议**：区分上层协议。1——ICMP，6 ——TCP，17——UDP。

**16 位头部校验和**：发送端填充，接收端对其使用 CRC 算法以检验 IP 数据报头部在传输过程中是否损坏。

**32 位的源端 IP 地址和目的端 IP 地址**：用来标识数据报的发送端和接收端。

**可变长的可选信息**：这部分最多包含 40 字节，因为 IP 头部最长是 60 字节。可用的 IP 选项包括：记录路由、时间戳、松散源路由选择、严格源路由选择。

### 2.3 IP 分片

 IP 数据报的长度超过帧的 MTU 时，它将被分片传输，分片可能发生在发送端、中转路由器上，也可能在传输过程中被多次分片。

IP 头部中的三个字段：数据报标识、标志和片偏移。

<div align="center"> <img src="Figs/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B_16.png" width="700"/> </div><br>

### 2.4 IP 路由

<u>数据报的路由</u>是 IP 协议的核心任务，其决定发送数据报到目标机器的路径。

#### 2.4.1 IP 模块工作流程

<div align="center"> <img src="Figs/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B_17.png" width="700"/> </div><br>

**从右往左分析**：

- 当 IP 模块收到来自数据链路层的 IP 数据报时，其首先对该数据报的头部做 CRC 校验，确认无误后分析其头部的具体信息。
- 若该 IP 数据报的头部设置了源站选路选项，则 IP 模块调用数据报转发子模块来处理该数据报。若该 IP 数据报的头部中目标 IP 地址是本机的某个 IP 地址，或者广播地址，即该数据报是发送给本机的，则 IP 模块就根据数据报头部中的协议字段来决定将它发给哪个上层应用。
- IP 输出队列中存放的是所有等待发送的 IP 数据报，其中除了需要转发的 IP 数据报之外，还包括封装了本机上层数据的 IP 数据报。
- 图中虚线箭头显示了路由表更新的过程，这一过程是指通过路由协议或者 route 命令调整路由表，使其适应最新的网络拓扑结构，称为 IP 路由策略。

#### 2.4.2 路由机制

```shell
# 查看路由表
route
netstat
```

<div align="center"> <img src="Figs/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B_18.png" width="700"/> </div><br>

<div align="center"> <img src="Figs/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B_19.png" width="700"/> </div><br>

**:star: IP 的路由机制**：

- 查找路由表中和数据报的目标 IP 地址完全匹配的主机 IP 地址，如果找到就使用该路由项。没有则转到步骤 2。
- 查找路由表中和数据报的目标 IP 地址具有相同网路 ID 的网络 IP 地址。如果找到就使用该路由项，没有找到就转到步骤3；
- 选择默认路由项，通常是网关。

#### 2.4.2 路由机制

通过 route 命令或者其他工具手动修改路由表是静态的路由更新方式；对于大型的路由器，它们常通过 BGP 、RIP 、OSPF 等协议来发现路径，并更新自己的路由表，这种更新方式是动态的、自动的。

### 2.5 IP 转发

路由器能执行数据报的转发操作，而主机一般只能发送和接收数据报，这是因为主机上 `/proc/sys/net/ipv4/ip_forward` 内核参数默认被设置为 0。我们可以通过修改它来使能主机的数据报转发功能：

```shell
# echo 1 > /proc/sys/net/ipv4/ip_forward
```

数据报转发子模块对于期望转发的数据报执行如下操作：

- 检查数据报头部的 TTL 值，如果 TTL 值已经是 0，则丢弃该数据报；
- 查看数据报头部的严格源路由选择选项。如果该选项被设置，则检测数据报的目标 IP 地址是否为本机的某个 IP 地址，如果不是则发送一个 ICMP 源站选路失败报文给发送端。
- 如果有必要，则给源端发送一个 ICMP 重定向报文，告诉它一个更合理的下一跳路由器；
- 将 TTL 值减1；
- 处理 IP 头部选项；
- 如果有必要的话，就执行 IP 分片操作；

###  2.6 重定向

####  2.6.1 ICMP 重定向报文

<div align="center"> <img src="Figs/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B_20.png" width="700"/> </div><br>

​	ICMP 重定向报文的类型值是 5，代码字段有 4 个可选值，用于区分不同的重定向类型。主机重定向代码值 为 1。ICMP 重定向报文的数据部分提供了两个信息：

- 引起重定向的 IP 数据报的源端 IP 地址；
- 应该使用的路由器的 IP 地址；

`/proc/sys/net/ipv4/conf/all/send_redirects` 内核参数指定是否允许发送 ICMP 重定向报文，`/proc/sys/net/ipv4/conf/all/accept_redirects` 内核参数指定是否允许接收 ICMP 重定向报文。主机一般只能接收 ICMP 重定向报文，而路由器只能发送 ICMP 重定向报文。

###  2.7 IPv6 头部结构

IPv6 不仅解决了 IPv4 地址不够用的问题，还增加了多播和流的功能，为网络上多媒体内容的质量提供精细的控制；引入了自动配置功能，使局域网管理更方便；增加了专门的网络安全功能。

####  2.7.1 IPv6 固定头部结构

IPv6 头部由 <u>40 字节的固定头部</u>和<u>可变长的扩展头部</u>组成。

<div align="center"> <img src="Figs/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B_21.png" width="700"/> </div><br>

**4 位版本号**：指定 IP 协议版本，值为 6 —— IPv6；

**8 位通信类型**：指示数据流通信类型或优先级，和 IPv4 中的 TOS 类似；

**20 位流标签**：IPv6 新增字段，用于某些对连接的服务质量特殊要求的通信；

**16 位净荷长度**：IPv6 扩展头部和应用程序数据长度之和，不包括固定头部长度；

**8 位下一个包头**： 指出紧跟 IPv6 固定头部后的包头类型，如扩展头或者某个上层协议头；

**8 位跳数限制**：和 IPv4 中的 TTL 含义相同；

IPv6 地址使用 " : " 分割为 8 组，每组包含 2 字节。**零压缩法**可以将其简写，也就是省略连续的、全零的组。不过零压缩法对一个 IPv6 地址只能使用一次。

####  2.7.2 IPv6 扩展头部

可变长的扩展头部使得 IPv6 能支持更多的选项，并且很便于将来的扩展需要。一个数据报可以包含多个扩展头部，每个扩展头部的类型是由前一个头部中的下一个报文字段指定。

<div align="center"> <img src="Figs/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B_22.png" width="700"/> </div><br>



## 第 3 章 TCP 协议详解

- TCP 头部信息。TCP 头部信息出现于每个 TCP 报文段中，用于指定通信的源端口号、目的端口号，管理 TCP 连接，控制两个方向的数据流；
- TCP 状态转移过程，TCP 连接的任意一端都是一个状态机，TCP 连接从建立到断开的过程中，连接两端的状态机将经历不同的状态变迁。
- TCP 数据流。分析 TCP 数据流，从网络应用程序外部来了解应用层协议和通信双方交换的应用程序数据。TCP 数据流：交互数据流、成块数据流、紧急数据流。
- TCP 数据流的控制。为保证可靠传输和提供网络通信质量，内核需要对 TCP 数据流进行控制。

### 3.1 TCP 服务的特点





















## 第 4 章 TCP / IP 通信案例：访问 Internet 上的 Web服务器

































# 第二篇（5 ~ 15）

服务器编程的主要方面，用实例代码阐述了相关重要概念、模型以及函数。

第一部分（5 ~ 7）：Linux 操作系统为网络编程提供的 API

第二部分（8）：高性能服务器程序的一般框架。服务器程序解构为 I / O单元、逻辑单元和存储单元三个部件，重点介绍  I / O单元、逻辑单元的几种高效实现模式，并探讨了提高服务器性能的建议；

第三部分（9 ~ 12）：剖析服务器程序的 I / O单元。 探讨 I / O单元需要处理的 I / O 事件、信号事件和定时事件，介绍开源的 I / O 框架库 Libevent；

第四部分（13 ~ 15）：剖析服务器程序的逻辑单元，讨论多线程、多进程编程以及高性能逻辑处理模型——进程池和线程池。

# 第三篇（16 ~ 17）

如何从系统的角度优化和监测服务器性能。服务器程序的调试和测试，常用系统监测工具的使用。



